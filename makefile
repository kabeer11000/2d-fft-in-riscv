# Define build directory and output file names
BUILD_DIR = build
ELF_FILE = $(BUILD_DIR)/hello.elf
# Add object files for new sources
MAIN_OBJ = $(BUILD_DIR)/main.o
START_OBJ = $(BUILD_DIR)/start.o
COMPLEX_OBJ = $(BUILD_DIR)/complex.o
MATH_OBJ = $(BUILD_DIR)/math_baremetal.o
FFT1D_OBJ = $(BUILD_DIR)/fft_1d_rvv.o
FFT2D_OBJ = $(BUILD_DIR)/fft_2d.o

LINK_SCRIPT = link.ld

# Define source file names located in the source/ subdirectory
MAIN_SRC = source/main.c
START_SRC = source/start.s
COMPLEX_SRC = source/complex.c
MATH_SRC = source/math_baremetal.c
FFT1D_SRC = source/fft_1d_rvv.c
FFT2D_SRC = source/fft_2d.c
# The image data header is generated by the script in source/
IMAGE_DATA_H = source/image_data.h

# Define compiler/assembler/linker
GCC = xpack-riscv-none-elf-gcc-14.2.0-3/bin/riscv-none-elf-gcc
AS = xpack-riscv-none-elf-gcc-14.2.0-3/bin/riscv-none-elf-as
LD = xpack-riscv-none-elf-gcc-14.2.0-3/bin/riscv-none-elf-ld

# Compiler flags:
# -c: Compile only, do not link
# -g: Include debug info
# -O0: No optimization (simplifies debugging)
# -ffreestanding: Compile for a freestanding environment (no standard library assumes math_baremetal provides needed functions)
# -march=rv32imacv: Specify architecture: RV32I + M (Mul/Div) + A (Atomics) + C (Compressed) + V (Vector)
#                   **ENSURE THIS MATCHES YOUR TARGET HARDWARE**
# -mabi=ilp32: Specify ABI
# -I. -I./source: Include current directory and source/ for headers
# -std=c99: Use C99 standard, often required for intrinsics headers
# -menable-experimental-extensions: Explicitly enable experimental GCC extensions, crucial for RISC-V Vector intrinsics
CFLAGS = -march=rv64gcv -mabi=lp64 -c -I. -I./source
AFLAGS = -g -march=rv32gcv -mabi=ilp32f
LFLAGS = -T $(LINK_SCRIPT) -m elf32lriscv

# All object files required for linking
OBJS = $(MAIN_OBJ) $(START_OBJ) $(COMPLEX_OBJ) $(MATH_OBJ) $(FFT1D_OBJ) $(FFT2D_OBJ)

# Default target: build the final executable
.PHONY: default
default: $(ELF_FILE)

# Rule to create the build directory if it doesn't exist
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# --- Compilation Rules (Explicit) ---

# Rule for compiling main.c (specific source path, depends on image data header)
$(MAIN_OBJ): $(MAIN_SRC) $(IMAGE_DATA_H) | $(BUILD_DIR)
	$(GCC) $(CFLAGS) -o $@ $<

# Rule for assembling start.s (specific source path)
$(START_OBJ): $(START_SRC) | $(BUILD_DIR)
	$(AS) $(AFLAGS) -o $@ $<

# Rule for compiling complex.c
$(COMPLEX_OBJ): $(COMPLEX_SRC) | $(BUILD_DIR)
	$(GCC) $(CFLAGS) -o $@ $<

# Rule for compiling math_baremetal.c
$(MATH_OBJ): $(MATH_SRC) | $(BUILD_DIR)
	$(GCC) $(CFLAGS) -o $@ $<

# Rule for compiling fft_1d_rvv.c
$(FFT1D_OBJ): $(FFT1D_SRC) | $(BUILD_DIR)
	$(GCC) $(CFLAGS) -o $@ $<

# Rule for compiling fft_2d.c
$(FFT2D_OBJ): $(FFT2D_SRC) | $(BUILD_DIR)
	$(GCC) $(CFLAGS) -o $@ $<

# --- Linking Rule ---

# Rule to link the object files into the final executable
# Depends on all object files and the linker script
$(ELF_FILE): $(OBJS) $(LINK_SCRIPT)
	$(LD) $(LFLAGS) -o $@ $(OBJS)

# --- Execution and Debugging Rules ---

# Rule to run the executable using QEMU
.PHONY: run
run: $(ELF_FILE)
	@echo "Ctrl-A C for QEMU console, then quit to exit"
	qemu-system-riscv32 -nographic -serial mon:stdio -machine virt -bios $(ELF_FILE)

# Rule to debug the executable using QEMU
.PHONY: debug
debug: $(ELF_FILE)
	@echo "Ctrl-A C for QEMU console, then quit to exit"
	qemu-system-riscv32 -nographic -serial mon:stdio -machine virt -s -S -bios $(ELF_FILE)

# --- Cleanup Rule ---

# Rule to clean up build files and directory
.PHONY: clean
clean:
	rm -rf $(BUILD_DIR)
