#include "image_data.h" // Generated by the Python script
#include <riscv_vector.h>
#include <math.h>       // For sinf, cosf, sqrtf (provided by libm, linked with dummy __errno)

// Define PI
#define PI 3.14159265358979323846f

// Complex number structure
typedef struct {
    float real;
    float imag;
} complex_t;

// --- Helper Functions for Complex Arithmetic using Vector Intrinsics ---
// These functions operate on vectors of complex_t, assuming real and imaginary
// parts are stored contiguously in memory for vload/vstore with stride 2.
// A fully vectorized approach would ideally use separate real/imaginary arrays.
// For simplicity in this example, we use complex_t array and demonstrate vector
// ops on elements loaded from it.

// Function to compute complex_out = complex_a + complex_b using vectors
// Operates on 'n' complex numbers starting from the given pointers.
void v_complex_add_contiguous(complex_t* restrict out,
                              const complex_t* restrict a,
                              const complex_t* restrict b, size_t n) {
    size_t vl;
    for (size_t i = 0; i < n; i += vl) {
        vl = __riscv_vsetvl_e32m1(n - i);

        // Load real and imaginary parts with a stride of 2
        vfloat32m1_t va_r = __riscv_vle32_v_f32m1(&a[i].real, vl);
        vfloat32m1_t va_i = __riscv_vle32_v_f32m1(&a[i].imag, vl); // Assumes imag is at &real + 4 bytes

        vfloat32m1_t vb_r = __riscv_vle32_v_f32m1(&b[i].real, vl);
        vfloat32m1_t vb_i = __riscv_vle32_v_f32m1(&b[i].imag, vl);

        // Perform vector addition
        vfloat32m1_t vout_r = __riscv_vfadd(va_r, vb_r, vl);
        vfloat32m1_t vout_i = __riscv_vfadd(va_i, vb_i, vl);

        // Store results with a stride of 2
        __riscv_vse32_v_f32m1(&out[i].real, vout_r, vl);
        __riscv_vse32_v_f32m1(&out[i].imag, vout_i, vl);
    }
}

// Function to compute complex_out = complex_a - complex_b using vectors
void v_complex_sub_contiguous(complex_t* restrict out,
                              const complex_t* restrict a,
                              const complex_t* restrict b, size_t n) {
    size_t vl;
    for (size_t i = 0; i < n; i += vl) {
        vl = __riscv_vsetvl_e32m1(n - i);

        vfloat32m1_t va_r = __riscv_vle32_v_f32m1(&a[i].real, vl);
        vfloat32m1_t va_i = __riscv_vle32_v_f32m1(&a[i].imag, vl);

        vfloat32m1_t vb_r = __riscv_vle32_v_f32m1(&b[i].real, vl);
        vfloat32m1_t vb_i = __riscv_vle32_v_f32m1(&b[i].imag, vl);

        vfloat32m1_t vout_r = __riscv_vfsub(va_r, vb_r, vl);
        vfloat32m1_t vout_i = __riscv_vfsub(va_i, vb_i, vl);

        __riscv_vse32_v_f32m1(&out[i].real, vout_r, vl);
        __riscv_vse32_v_f32m1(&out[i].imag, vout_i, vl);
    }
}


// Function to compute complex_out = complex_a * complex_b using vectors
void v_complex_mul_contiguous(complex_t* restrict out,
                              const complex_t* restrict a,
                              const complex_t* restrict b, size_t n) {
    size_t vl;
    for (size_t i = 0; i < n; i += vl) {
        vl = __riscv_vsetvl_e32m1(n - i);

        vfloat32m1_t va_r = __riscv_vle32_v_f32m1(&a[i].real, vl);
        vfloat32m1_t va_i = __riscv_vle32_v_f32m1(&a[i].imag, vl);
        vfloat32m1_t vb_r = __riscv_vle32_v_f32m1(&b[i].real, vl);
        vfloat32m1_t vb_i = __riscv_vle32_v_f32m1(&b[i].imag, vl);

        // (a.real * b.real - a.imag * b.imag)
        vfloat32m1_t out_r = __riscv_vfmv_v_f_f32m1(0.0f, vl);
        out_r = __riscv_vfmacc(out_r, va_r, vb_r, vl);
        out_r = __riscv_vfnmsac(out_r, va_i, vb_i, vl); // Fused Negated Multiply-Accumulate

        // (a.real * b.imag + a.imag * b.real)
        vfloat32m1_t out_i = __riscv_vfmv_v_f_f32m1(0.0f, vl);
        out_i = __riscv_vfmacc(out_i, va_r, vb_i, vl);
        out_i = __riscv_vfmacc(out_i, va_i, vb_r, vl);

        __riscv_vse32_v_f32m1(&out[i].real, out_r, vl);
        __riscv_vse32_v_f32m1(&out[i].imag, out_i, vl);
    }
}


// --- Utility: Bit-Reversal Permutation (Non-vectorized for simplicity) ---
// This is often a serial bottleneck in FFT implementations.
void bit_reversal_permutation(complex_t* data, int n) {
    int i, j, k;
    complex_t temp;
    j = 0;
    for (i = 0; i < n; ++i) {
        if (j > i) {
            temp = data[i];
            data[i] = data[j];
            data[j] = temp;
        }
        k = n / 2;
        while (k >= 1 && j >= k) {
            j -= k;
            k /= 2;
        }
        j += k;
    }
}

// --- 1D FFT Implementation ---
// data: Input/output array of complex numbers
// n: Size of the array (must be a power of 2)
// is_inverse: 0 for forward FFT, 1 for inverse FFT (scaling only)
void fft_1d(complex_t* data, int n, int is_inverse) {
    if (n <= 1) return;

    // Apply bit-reversal permutation
    bit_reversal_permutation(data, n);

    // Perform FFT stages
    for (int len = 2; len <= n; len <<= 1) {
        float angle_unit = -2 * PI / len; // Forward FFT
        if (is_inverse) angle_unit = -angle_unit; // Inverse FFT

        // Process blocks of size 'len'
        for (int i = 0; i < n; i += len) {
            // Process len/2 butterflies within the block
            int half_len = len / 2;
            size_t vl;
            for (size_t j = 0; j < half_len; j += vl) {
                vl = __riscv_vsetvl_e32m1(half_len - j); // Vector length up to half_len

                // Calculate twiddle factors for this vector segment
                // Need to compute cosf and sinf for indices j, j+1, ..., j+vl-1
                // This part is still scalar calculation of twiddle factors
                // as sinf/cosf aren't typically vectorized intrinsics directly.
                // A precomputed table would be faster if memory allows.
                float twiddle_r[vl]; // Temporary storage for twiddle factors
                float twiddle_i[vl];
                for(size_t k=0; k<vl; ++k) {
                    float angle = (j + k) * angle_unit;
                    twiddle_r[k] = cosf(angle);
                    twiddle_i[k] = sinf(angle);
                }

                // Load vector segments for even and odd parts
                complex_t* even_ptr = &data[i + j];
                complex_t* odd_ptr = &data[i + j + half_len];

                vfloat32m1_t even_r = __riscv_vle32_v_f32m1(&even_ptr->real, vl);
                vfloat32m1_t even_i = __riscv_vle32_v_f32m1(&even_ptr->imag, vl);

                vfloat32m1_t odd_r = __riscv_vle32_v_f32m1(&odd_ptr->real, vl);
                vfloat32m1_t odd_i = __riscv_vle32_v_f32m1(&odd_ptr->imag, vl);

                // Load vector twiddle factors
                vfloat32m1_t w_r = __riscv_vle32_v_f32m1(twiddle_r, vl); // Load from temp buffer
                vfloat32m1_t w_i = __riscv_vle32_v_f32m1(twiddle_i, vl);

                // Calculate w * odd (vector complex multiplication)
                // temp_r = odd_r * w_r - odd_i * w_i
                vfloat32m1_t temp_r = __riscv_vfmv_v_f_f32m1(0.0f, vl);
                temp_r = __riscv_vfmacc(temp_r, odd_r, w_r, vl);
                temp_r = __riscv_vfnmsac(temp_r, odd_i, w_i, vl);

                // temp_i = odd_r * w_i + odd_i * w_r
                vfloat32m1_t temp_i = __riscv_vfmv_v_f_f32m1(0.0f, vl);
                temp_i = __riscv_vfmacc(temp_i, odd_r, w_i, vl);
                temp_i = __riscv_vfmacc(temp_i, odd_i, w_r, vl);

                // Calculate butterfly: even + temp and even - temp (vector complex add/sub)
                vfloat32m1_t out1_r = __riscv_vfadd(even_r, temp_r, vl); // Corresponds to data[k].real
                vfloat32m1_t out1_i = __riscv_vfadd(even_i, temp_i, vl); // Corresponds to data[k].imag

                vfloat32m1_t out2_r = __riscv_vfsub(even_r, temp_r, vl); // Corresponds to data[k + half_len].real
                vfloat32m1_t out2_i = __riscv_vfsub(even_i, temp_i, vl); // Corresponds to data[k + half_len].imag

                // Store results back to the original array
                __riscv_vse32_v_f32m1(&even_ptr->real, out1_r, vl);
                __riscv_vse32_v_f32m1(&even_ptr->imag, out1_i, vl);
                __riscv_vse32_v_f32m1(&odd_ptr->real, out2_r, vl);
                __riscv_vse32_v_f32m1(&odd_ptr->imag, out2_i, vl);
            }
        }
    }

    // Apply scaling for inverse FFT (divide by N).
    // Not strictly necessary for forward FFT visualization, but good practice
    // if you intend to perform an inverse transform later.
    // if (is_inverse) {
    //     float scale = 1.0f / n;
    //     size_t vl;
    //     for (size_t i = 0; i < n; i += vl) {
    //         vl = __riscv_vsetvl_e32m1(n - i);
    //         vfloat32m1_t v_r = __riscv_vle32_v_f32m1(&data[i].real, vl);
    //         vfloat32m1_t v_i = __riscv_vle32_v_f32m1(&data[i].imag, vl);
    //         v_r = __riscv_vfmul(v_r, scale, vl);
    //         v_i = __riscv_vfmul(v_i, scale, vl);
    //         __riscv_vse32_v_f32m1(&data[i].real, v_r, vl);
    //         __riscv_vse32_v_f32m1(&data[i].imag, v_i, vl);
    //     }
    // }
}


// --- 2D FFT Implementation ---
// data: 2D data flattened into a 1D array (row-major)
// width, height: Dimensions of the 2D data (must be powers of 2)
void fft_2d(complex_t* data, int width, int height) {
    // Ensure dimensions are powers of 2 (should be handled by Python script)
    if ((width & (width - 1)) != 0 || (height & (height - 1)) != 0) {
        // In a real bare-metal scenario, you might halt or signal an error here
        // For this example, we assume valid power-of-2 dimensions from the script.
        // An infinite loop is a common bare-metal way to halt on error.
         while(1);
    }

    // 1. Perform 1D FFT on each row
    for (int y = 0; y < height; ++y) {
        fft_1d(&data[y * width], width, 0); // Operate on the row starting at data[y * width]
    }

    // 2. Perform 1D FFT on each column
    // This is tricky with row-major storage. We extract columns into a temp buffer.
    // For larger data, this transpose/copy can be a bottleneck.
    static complex_t temp_col_data[IMAGE_HEIGHT]; // Static allocation or dynamic if malloc is available

    for (int x = 0; x < width; ++x) {
        // Extract column 'x' into temp_col_data
        for (int y = 0; y < height; ++y) {
            temp_col_data[y] = data[y * width + x];
        }

        // Perform 1D FFT on the column data
        fft_1d(temp_col_data, height, 0);

        // Copy the processed column data back to the original array
        for (int y = 0; y < height; ++y) {
            data[y * width + x] = temp_col_data[y];
        }
    }
}

// --- Output Function (using minimal putchar or semi-hosting) ---
// This function provides basic character output. On QEMU virt with -nographic,
// writing to address 0x10000000 often routes to the console.
void my_putchar(char c) {
    volatile char *uart = (volatile char *)0x10000000;
    *uart = c;
}

// Helper function to print a string using my_putchar
void my_puts(const char* s) {
    while (*s) {
        my_putchar(*s);
        s++;
    }
}

// Basic float to string conversion for bare-metal output
// This is simplified and might not handle all float values/precisions perfectly.
// A proper implementation is more complex or relies on semi-hosting printf.
void print_float(float f) {
    if (f < 0) {
        my_putchar('-');
        f = -f;
    }

    // Print integer part
    int integer_part = (int)f;
    if (integer_part == 0) {
        my_putchar('0');
    } else {
        // Determine the largest power of 10 less than or equal to integer_part
        int temp = integer_part;
        int divisor = 1;
        while (temp / 10 > 0) {
            divisor *= 10;
            temp /= 10;
        }
        // Print digits from most significant
        while (divisor > 0) {
            my_putchar('0' + (integer_part / divisor) % 10);
            divisor /= 10;
        }
    }

    my_putchar('.'); // Decimal point

    // Print fractional part (basic fixed precision, e.g., 6 decimal places)
    float fractional_part = f - (int)f;
    for (int i = 0; i < 6; ++i) {
        fractional_part *= 10;
        int digit = (int)fractional_part;
        my_putchar('0' + digit);
        fractional_part -= digit; // Subtract the printed digit
    }
}

extern void _start(void);
void _start() {
    my_putchar('c');
}
// --- Main Entry Point ---
// The linker will typically start execution here (or at _start if defined).
int main() {
    // Allocate memory for complex data and output magnitude
    // Using static allocation as dynamic allocation might not be available
    // Size is determined by IMAGE_WIDTH * IMAGE_HEIGHT from the header
    static complex_t image_complex_data[IMAGE_WIDTH * IMAGE_HEIGHT];
    static float fft_magnitude_output[IMAGE_WIDTH * IMAGE_HEIGHT];

    // Initialize complex data from the embedded input_image_data
    // Input image is grayscale, so imaginary part is 0
    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; ++i) {
        image_complex_data[i].real = input_image_data[i]; // Assuming input_image_data contains floats (0-255)
        image_complex_data[i].imag = 0.0f;
    }

    // Print a message to indicate start of FFT (optional)
    my_puts("Starting 2D FFT...\n");

    // Perform 2D FFT on the complex data
    fft_2d(image_complex_data, IMAGE_WIDTH, IMAGE_HEIGHT);

    my_puts("FFT completed. Calculating magnitude...\n");

    // Calculate magnitude for visualization: sqrt(real*real + imag*imag)
    // This loop calculates magnitude for each complex number in the result
    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; ++i) {
         fft_magnitude_output[i] = sqrtf(image_complex_data[i].real * image_complex_data[i].real +
                                         image_complex_data[i].imag * image_complex_data[i].imag);
    }

    my_puts("Magnitude calculated. Outputting data...\n");

    // Output the magnitude data to the console
    // The Python script will capture and parse this output
    for (int i = 0; i < IMAGE_WIDTH * IMAGE_HEIGHT; ++i) {
        print_float(fft_magnitude_output[i]);
        my_putchar(','); // Use comma as a separator

        // Add a newline after each row for easier debugging/viewing (optional)
        if ((i + 1) % IMAGE_WIDTH == 0) {
             my_putchar('\n');
        }
    }

    my_puts("DONE\n"); // Signal the Python script that output is complete

    // Bare-metal programs typically end in an infinite loop
    // or jump to a platform-specific exit/power-off routine if available.
    // An infinite loop prevents unpredictable behavior after main finishes.
    while (1);

    return 0; // This return is technically unreachable
}